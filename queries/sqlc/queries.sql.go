// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAPIKey = `-- name: CreateAPIKey :one
INSERT INTO api_keys (key, user_id, created_at)
VALUES ($1, $2, $3)
RETURNING key, user_id, created_at
`

type CreateAPIKeyParams struct {
	Key       uuid.UUID        `json:"key"`
	UserID    uuid.UUID        `json:"user_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) (ApiKey, error) {
	row := q.db.QueryRow(ctx, createAPIKey, arg.Key, arg.UserID, arg.CreatedAt)
	var i ApiKey
	err := row.Scan(&i.Key, &i.UserID, &i.CreatedAt)
	return i, err
}

const createURL = `-- name: CreateURL :one
INSERT INTO urls (short_id, long_url, user_id, created_at, expires_at, click_limit)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING short_id, long_url, user_id, created_at, expires_at, click_limit
`

type CreateURLParams struct {
	ShortID    string           `json:"short_id"`
	LongUrl    string           `json:"long_url"`
	UserID     pgtype.UUID      `json:"user_id"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	ExpiresAt  pgtype.Timestamp `json:"expires_at"`
	ClickLimit pgtype.Int4      `json:"click_limit"`
}

func (q *Queries) CreateURL(ctx context.Context, arg CreateURLParams) (Url, error) {
	row := q.db.QueryRow(ctx, createURL,
		arg.ShortID,
		arg.LongUrl,
		arg.UserID,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.ClickLimit,
	)
	var i Url
	err := row.Scan(
		&i.ShortID,
		&i.LongUrl,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.ClickLimit,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (user_id, username, email, created_at)
VALUES ($1, $2, $3, $4)
RETURNING user_id, username, email, created_at, updated_at
`

type CreateUserParams struct {
	UserID    uuid.UUID        `json:"user_id"`
	Username  string           `json:"username"`
	Email     string           `json:"email"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

// queries.sql
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserID,
		arg.Username,
		arg.Email,
		arg.CreatedAt,
	)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAPIKey = `-- name: DeleteAPIKey :exec
DELETE FROM api_keys WHERE key = $1 AND user_id = $2
`

type DeleteAPIKeyParams struct {
	Key    uuid.UUID `json:"key"`
	UserID uuid.UUID `json:"user_id"`
}

func (q *Queries) DeleteAPIKey(ctx context.Context, arg DeleteAPIKeyParams) error {
	_, err := q.db.Exec(ctx, deleteAPIKey, arg.Key, arg.UserID)
	return err
}

const deleteURL = `-- name: DeleteURL :exec
DELETE FROM urls WHERE short_id = $1 AND user_id = $2
`

type DeleteURLParams struct {
	ShortID string      `json:"short_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteURL(ctx context.Context, arg DeleteURLParams) error {
	_, err := q.db.Exec(ctx, deleteURL, arg.ShortID, arg.UserID)
	return err
}

const getAPIKey = `-- name: GetAPIKey :one
SELECT key, user_id, created_at FROM api_keys WHERE key = $1
`

func (q *Queries) GetAPIKey(ctx context.Context, key uuid.UUID) (ApiKey, error) {
	row := q.db.QueryRow(ctx, getAPIKey, key)
	var i ApiKey
	err := row.Scan(&i.Key, &i.UserID, &i.CreatedAt)
	return i, err
}

const getTotalClicks = `-- name: GetTotalClicks :one
SELECT COUNT(*) as total FROM clicks
`

func (q *Queries) GetTotalClicks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalClicks)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTotalURLs = `-- name: GetTotalURLs :one
SELECT COUNT(*) as total FROM urls
`

func (q *Queries) GetTotalURLs(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalURLs)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getTotalUsers = `-- name: GetTotalUsers :one
SELECT COUNT(*) as total FROM users
`

func (q *Queries) GetTotalUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalUsers)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getURL = `-- name: GetURL :one
SELECT short_id, long_url, user_id, created_at, expires_at, click_limit FROM urls WHERE short_id = $1
`

func (q *Queries) GetURL(ctx context.Context, shortID string) (Url, error) {
	row := q.db.QueryRow(ctx, getURL, shortID)
	var i Url
	err := row.Scan(
		&i.ShortID,
		&i.LongUrl,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.ClickLimit,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT user_id, username, email, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, username, email, created_at, updated_at FROM users WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listClicks = `-- name: ListClicks :many
SELECT id, short_id, ip_address, user_agent, clicked_at FROM clicks WHERE short_id = $1
`

func (q *Queries) ListClicks(ctx context.Context, shortID pgtype.Text) ([]Click, error) {
	rows, err := q.db.Query(ctx, listClicks, shortID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Click
	for rows.Next() {
		var i Click
		if err := rows.Scan(
			&i.ID,
			&i.ShortID,
			&i.IpAddress,
			&i.UserAgent,
			&i.ClickedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAPIKeys = `-- name: ListUserAPIKeys :many
SELECT key, user_id, created_at FROM api_keys WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListUserAPIKeys(ctx context.Context, userID uuid.UUID) ([]ApiKey, error) {
	rows, err := q.db.Query(ctx, listUserAPIKeys, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiKey
	for rows.Next() {
		var i ApiKey
		if err := rows.Scan(&i.Key, &i.UserID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserURLs = `-- name: ListUserURLs :many
SELECT short_id, long_url, user_id, created_at, expires_at, click_limit FROM urls WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) ListUserURLs(ctx context.Context, userID pgtype.UUID) ([]Url, error) {
	rows, err := q.db.Query(ctx, listUserURLs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Url
	for rows.Next() {
		var i Url
		if err := rows.Scan(
			&i.ShortID,
			&i.LongUrl,
			&i.UserID,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.ClickLimit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logClick = `-- name: LogClick :exec
INSERT INTO clicks (short_id, ip_address, user_agent, clicked_at)
VALUES ($1, $2, $3, $4)
`

type LogClickParams struct {
	ShortID   pgtype.Text      `json:"short_id"`
	IpAddress pgtype.Text      `json:"ip_address"`
	UserAgent pgtype.Text      `json:"user_agent"`
	ClickedAt pgtype.Timestamp `json:"clicked_at"`
}

func (q *Queries) LogClick(ctx context.Context, arg LogClickParams) error {
	_, err := q.db.Exec(ctx, logClick,
		arg.ShortID,
		arg.IpAddress,
		arg.UserAgent,
		arg.ClickedAt,
	)
	return err
}

const updateURL = `-- name: UpdateURL :one
UPDATE urls
SET long_url = COALESCE($2, long_url),
    expires_at = COALESCE($3, expires_at),
    click_limit = COALESCE($4, click_limit)
WHERE short_id = $1 AND user_id = $5
RETURNING short_id, long_url, user_id, created_at, expires_at, click_limit
`

type UpdateURLParams struct {
	ShortID    string           `json:"short_id"`
	LongUrl    string           `json:"long_url"`
	ExpiresAt  pgtype.Timestamp `json:"expires_at"`
	ClickLimit pgtype.Int4      `json:"click_limit"`
	UserID     pgtype.UUID      `json:"user_id"`
}

func (q *Queries) UpdateURL(ctx context.Context, arg UpdateURLParams) (Url, error) {
	row := q.db.QueryRow(ctx, updateURL,
		arg.ShortID,
		arg.LongUrl,
		arg.ExpiresAt,
		arg.ClickLimit,
		arg.UserID,
	)
	var i Url
	err := row.Scan(
		&i.ShortID,
		&i.LongUrl,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.ClickLimit,
	)
	return i, err
}
